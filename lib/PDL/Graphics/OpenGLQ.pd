use strict;
use warnings;
use PDL::Types qw(types ppdefs_all);

{ no warnings 'once'; # pass info back to Makefile.PL
$PDL::Core::Dev::EXTRAS{$::PDLMOD}{OBJECT} .= join '', map " $::PDLBASE-$_\$(OBJ_EXT)", qw(font sphere);
}

my $F = ['F'];

pp_addpm({At=>'Top'},<<'EOD');
=head1 NAME

PDL::Graphics::OpenGLQ - quick routines to plot lots of stuff from ndarrays.

=head1 SYNOPSIS

only for internal use - see source

=head1 DESCRIPTION

only for internal use - see source

=head1 AUTHOR

Copyright (C) 1997,1998 Tuomas J. Lukka.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD

pp_addhdr('
#ifdef __APPLE__
#include <OpenGL/gl.h>
#else
#include <GL/gl.h>
#endif

#define PDL_3D_CROSS(to, v1, v2) \
  { \
    to[0] = v1[1]*v2[2] - v2[1]*v1[2]; \
    to[1] = -(v1[0]*v2[2] - v2[0]*v1[2]); \
    to[2] = v1[0]*v2[1] - v2[0]*v1[1]; \
  }
#define PDL_3D_VECLEN(v) \
  sqrtf(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
#define PDL_3D_SETVECLEN(v, newlen) \
  { \
    float len = PDL_3D_VECLEN(v), fac = newlen/len; \
    int i; \
    for (i = 0; i < 3; i++) v[i] *= fac; \
  }
');

my @internal = (Doc => 'internal', NoPthread => 1);

pp_def(
  'gl_spheres',
  GenericTypes => $F,
  Pars => 'coords(tri=3,n);',
  OtherPars => 'double radius; int slices; int stacks;',
  CHeader => "char *pdl_3d_solidSphere(double radius, GLint slices, GLint stacks);\n",
  Code => '
    float oldcoord0 = 0.0, oldcoord1 = 0.0, oldcoord2 = 0.0;
    glPushMatrix();
    loop(n) %{
      glTranslatef(
	$coords(tri=>0) - oldcoord0,
	$coords(tri=>1) - oldcoord1,
	$coords(tri=>2) - oldcoord2
      );
      char *err = pdl_3d_solidSphere($COMP(radius), $COMP(slices), $COMP(stacks));
      if (err) $CROAK("%s", err);
      oldcoord0 = $coords(tri=>0), oldcoord1 = $coords(tri=>1), oldcoord2 = $coords(tri=>2);
    %}
    glPopMatrix();
  ',
  @internal
);

sub TRI {
  my ($par, $suffix, $var) = @_;
  $par .= $suffix if $suffix && !ref $suffix;
  $var //= 'trivert';
  my $extra_arg = ref $suffix ? "$var => $$suffix," : '';
  join ',', map "$par(${extra_arg}tri => $_)", 0..2;
}
sub make_tri { shift()."(".TRI(@_).");\n" }
sub RPOS { make_tri("glRasterPos3f",'$coords',@_) }

pp_def(
  'gl_texts',
  GenericTypes => $F,
  Pars => 'coords(tri=3,x); ',
  OtherPars => 'SV *arr',
  CHeader => "void pdl_3d_bitmapString( const unsigned char *string );\n",
  Code => '
    SV *sv = $COMP(arr);
    if (!(SvROK(sv) && SvTYPE(SvRV(sv))==SVt_PVAV))
      $CROAK("gl_texts requires an array ref");
    AV *arr = (AV *)SvRV(sv);
    loop(x) %{
      SV *elem = *(av_fetch(arr, x, 0));
      if (!elem) continue;
      char *str = SvPV_nolen(elem);
      '.RPOS().'
      pdl_3d_bitmapString((const unsigned char *)str);
    %}
  ',
  @internal
);

pp_def(
  'gl_font_texture',
  GenericTypes => ['B'],
  Pars => '[o] texture(width=CALC(pdl_3d_bitmapFontWidth()),height=CALC(pdl_3d_bitmapHeight()));
    int [o] rightbound(c=CALC(pdl_3d_bitmapFontQuantity())); float [o] orig(o=2)',
  CHeader => <<'EOF',
int pdl_3d_bitmapFontWidth(void);
int pdl_3d_bitmapHeight(void);
int pdl_3d_bitmapFontQuantity(void);
void pdl_3d_bitmapFontBounds(int32_t *out);
const GLubyte* pdl_3d_bitmapFontChar(unsigned char i);
float pdl_3d_bitmapFontXOrig(void);
float pdl_3d_bitmapFontYOrig(void);
EOF
  Code => <<'EOF',
pdl_3d_bitmapFontBounds($P(rightbound));
loop (c) %{
  const GLubyte *d = pdl_3d_bitmapFontChar(c);
  PDL_Indx left = !c ? 0 : $rightbound(c=>c-1)+1, right = $rightbound()+1,
    bytesperrow = (7 + right - left) / 8;
  loop (height,width=left:right) %{
    PDL_Indx whichcol = width - left, whichbit = 7 - (whichcol % 8),
      whichbyte = height * bytesperrow + (whichcol / 8);
    GLubyte thebyte = d[whichbyte + 1];
    $texture() = (thebyte & (1 << whichbit)) ? 1 : 0;
  %}
%}
$orig(o=>0) = pdl_3d_bitmapFontXOrig();
$orig(o=>1) = pdl_3d_bitmapFontYOrig();
EOF
  @internal
);

pp_def('gen_arrowheads',
  Pars => 'coords(tri=3,v); uint fromto(ft=2,n); [o] trivertices(tri,nv=CALC(5*$SIZE(n))); uint [o] triindices(trivert=3,ni=CALC(4*$SIZE(n)))',
  OtherPars => 'float headlen; float width;',
  GenericTypes => $F,
  Code => <<'EOF',
float hl = $COMP(headlen);
float w = $COMP(width);
if (w == 0)
  $CROAK("width invalid: cannot be 0");
float tmp2[3] = { 0.000001, -0.0001, 1 };
broadcastloop %{
loop(n) %{
  PDL_ULong a = $fromto(ft=>0), b = $fromto(ft=>1), nvbase = n * 5, nibase = n * 4;
  if (a >= $SIZE(v))
    $CROAK("indsa number %"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, n, a, $SIZE(v)-1);
  if (b >= $SIZE(v))
    $CROAK("indsb number %"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, n, b, $SIZE(v)-1);
  float tmp1[3], norm[3], norm2[3], partback[3];
  loop(tri) %{
    tmp1[tri] = $coords(v => a) - $coords(v => b);
    partback[tri] = $coords(v => b) + hl*tmp1[tri];
  %}
  PDL_3D_CROSS(norm, tmp1, tmp2);
  PDL_3D_CROSS(norm2, tmp1, norm);
  float wthis = w*PDL_3D_VECLEN(tmp1);
  PDL_3D_SETVECLEN(norm, wthis);
  PDL_3D_SETVECLEN(norm2, wthis);
  PDL_3D_SETVECLEN(tmp1, 1);
  loop(tri) %{ $trivertices(nv=>nvbase+0) = $coords(v => b); %}
  loop(tri) %{ $trivertices(nv=>nvbase+1) = partback[tri] + norm[tri]; %}
  loop(tri) %{ $trivertices(nv=>nvbase+2) = partback[tri] + norm2[tri]; %}
  loop(tri) %{ $trivertices(nv=>nvbase+3) = partback[tri] - norm[tri]; %}
  loop(tri) %{ $trivertices(nv=>nvbase+4) = partback[tri] - norm2[tri]; %}
  $triindices(trivert=>0,ni=>nibase+0) = nvbase+0;
  $triindices(trivert=>1,ni=>nibase+0) = nvbase+1;
  $triindices(trivert=>2,ni=>nibase+0) = nvbase+2;
  $triindices(trivert=>0,ni=>nibase+1) = nvbase+0;
  $triindices(trivert=>1,ni=>nibase+1) = nvbase+3;
  $triindices(trivert=>2,ni=>nibase+1) = nvbase+4;
  $triindices(trivert=>0,ni=>nibase+2) = nvbase+0;
  $triindices(trivert=>1,ni=>nibase+2) = nvbase+2;
  $triindices(trivert=>2,ni=>nibase+2) = nvbase+3;
  $triindices(trivert=>0,ni=>nibase+3) = nvbase+0;
  $triindices(trivert=>1,ni=>nibase+3) = nvbase+4;
  $triindices(trivert=>2,ni=>nibase+3) = nvbase+1;
%}
%}
EOF
  Doc => <<'EOF',
=for ref

Generate vertices and indices, for triangles, implementing arrowheads.
EOF
);

pp_def('triangle_normals',
  Pars => 'vertices(tri=3,v); uint faceidx(trivert=3,f); [o] facenorm(tri,f); [o] vertnorm(tri,v)',
  GenericTypes => $F,
  Code => <<'EOF',
loop(v,tri) %{ $vertnorm() = 0.0f; %}
loop(f) %{
  float tmp0_1[3], tmp0_2[3], tmpcross[3];
  PDL_ULong vertidx[3];
  loop(trivert) %{
    if ((vertidx[trivert] = $faceidx()) >= $SIZE(v))
      $CROAK("faceidx number %"IND_FLAG",%"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, f, trivert, vertidx[trivert], $SIZE(v)-1);
  %}
  loop(tri) %{
    tmp0_1[tri] = $vertices(v => vertidx[1]) - $vertices(v => vertidx[0]);
    tmp0_2[tri] = $vertices(v => vertidx[2]) - $vertices(v => vertidx[0]);
  %}
  PDL_3D_CROSS(tmpcross, tmp0_1, tmp0_2);
  PDL_3D_SETVECLEN(tmpcross, 1);
  loop(tri) %{ $facenorm() = tmpcross[tri]; %}
  loop(trivert,tri) %{ $vertnorm(v=>vertidx[trivert]) += $facenorm(); %}
%}
loop(v) %{
  float magn = sqrtf($vertnorm(tri=>0)*$vertnorm(tri=>0) + $vertnorm(tri=>1)*$vertnorm(tri=>1) + $vertnorm(tri=>2)*$vertnorm(tri=>2));
  loop(tri) %{ $vertnorm() /= magn; %}
%}
EOF
  Doc => <<'EOF',
=for ref

Generate normals for faces and vertices in a single scan.
EOF
);

pp_done();
