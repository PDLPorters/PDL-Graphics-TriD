use strict;
use warnings;
use PDL::Types qw(types ppdefs_all);

{ no warnings 'once'; # pass info back to Makefile.PL
$PDL::Core::Dev::EXTRAS{$::PDLMOD}{OBJECT} .= join '', map " $::PDLBASE-$_\$(OBJ_EXT)", qw(font sphere);
}

my $F = ['F'];

pp_addpm({At=>'Top'},<<'EOD');
=head1 NAME

PDL::Graphics::OpenGLQ - quick routines to plot lots of stuff from ndarrays.

=head1 SYNOPSIS

only for internal use - see source

=head1 DESCRIPTION

only for internal use - see source

=head1 AUTHOR

Copyright (C) 1997,1998 Tuomas J. Lukka.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD

pp_addhdr('
#ifdef __APPLE__
#include <OpenGL/gl.h>
#else
#include <GL/gl.h>
#endif

#define PDL_3D_CROSS(to, v1, v2) \
  { \
    to[0] = v1[1]*v2[2] - v2[1]*v1[2]; \
    to[1] = -(v1[0]*v2[2] - v2[0]*v1[2]); \
    to[2] = v1[0]*v2[1] - v2[0]*v1[1]; \
  }
#define PDL_3D_VECLEN(v) \
  sqrtf(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])
#define PDL_3D_SETVECLEN(v, newlen) \
  { \
    float len = PDL_3D_VECLEN(v), fac = newlen/len; \
    int i; \
    for (i = 0; i < 3; i++) v[i] *= fac; \
  }
');

my @internal = (Doc => 'internal', NoPthread => 1);

pp_def(
  'gl_spheres',
  GenericTypes => $F,
  Pars => 'coords(tri=3,n);',
  OtherPars => 'double radius; int slices; int stacks;',
  CHeader => "char *pdl_3d_solidSphere(double radius, GLint slices, GLint stacks);\n",
  Code => '
    float oldcoord0 = 0.0, oldcoord1 = 0.0, oldcoord2 = 0.0;
    glPushMatrix();
    loop(n) %{
      glTranslatef(
	$coords(tri=>0) - oldcoord0,
	$coords(tri=>1) - oldcoord1,
	$coords(tri=>2) - oldcoord2
      );
      char *err = pdl_3d_solidSphere($COMP(radius), $COMP(slices), $COMP(stacks));
      if (err) $CROAK("%s", err);
      oldcoord0 = $coords(tri=>0), oldcoord1 = $coords(tri=>1), oldcoord2 = $coords(tri=>2);
    %}
    glPopMatrix();
  ',
  @internal
);

sub TRI {
  my ($par, $suffix) = @_;
  $par .= $suffix if $suffix && !ref $suffix;
  my $extra_arg = ref $suffix ? "trivert => $$suffix," : '';
  join ',', map "$par(${extra_arg}tri => $_)", 0..2;
}
sub make_tri { shift()."(".TRI(@_).");\n" }
sub COLOR { make_tri("glColor3f",'$colors',@_) }
sub VERTEX { make_tri("glVertex3f",'$coords',@_) }
sub NORMAL { make_tri("glNormal3f",'$norm',@_) }
sub RPOS { make_tri("glRasterPos3f",'$coords',@_) }

sub make_func {
  my ($name) = @_;
  for (['_col', ' colors(tri=3,n);', COLOR().VERTEX()]) {
    pp_def(lc($name).$_->[0],
      GenericTypes => $F,
      Pars => 'coords(tri=3,n);'.$_->[1],
      Code => '
        glBegin('.uc($name).');
        loop(n) %{'.$_->[2].'%}
        glEnd();
      ',
      @internal
    );
  }
}

make_func($_) for qw(gl_line_strip gl_lines gl_points);

pp_def(
  'gl_texts',
  GenericTypes => $F,
  Pars => 'coords(tri=3,x); ',
  OtherPars => 'SV *arr',
  CHeader => "void pdl_3d_bitmapString( const unsigned char *string );\n",
  Code => '
    SV *sv = $COMP(arr);
    if (!(SvROK(sv) && SvTYPE(SvRV(sv))==SVt_PVAV))
      $CROAK("gl_texts requires an array ref");
    AV *arr = (AV *)SvRV(sv);
    loop(x) %{
      SV *elem = *(av_fetch(arr, x, 0));
      if (!elem) continue;
      char *str = SvPV_nolen(elem);
      '.RPOS().'
      pdl_3d_bitmapString((const unsigned char *)str);
    %}
  ',
  @internal
);

for(
{Name => 'gl_triangles'},
{Name => 'gl_triangles_wn',
 NormalArgs => 'norm(tri,trivert); ',
 (map +("NormalCode$_"=>NORMAL(\$_)), 0..2),
}) {
# This may be suboptimal but should still be fast enough..
# We only do triangles with this.
pp_def(
  $_->{Name},
  GenericTypes => $F,
  Pars => 'coords(tri=3,trivert=3); '.
           ($_->{NormalArgs}//'').
          'colors(tri,trivert)',
  Code => '
glBegin(GL_TRIANGLES);
broadcastloop %{'.
  ($_->{NormalCode0}//'').
  COLOR(\0).VERTEX(\0).
  ($_->{NormalCode1}//'').
  COLOR(\1).VERTEX(\1).
  ($_->{NormalCode2}//'').
  COLOR(\2).VERTEX(\2).'
%}
glEnd();',
  @internal
);
}

pp_def('gen_arrowheads',
  Pars => 'coords(tri=3,v); uint indsa(n); uint indsb(n); [o] trivertices(tri,nv=CALC(5*$SIZE(n))); uint [o] triindices(ni=CALC(12*$SIZE(n)))',
  OtherPars => 'float headlen; float width;',
  GenericTypes => $F,
  Code => <<'EOF',
float hl = $COMP(headlen);
float w = $COMP(width);
if (w == 0)
  $CROAK("width invalid: cannot be 0");
float tmp2[3] = { 0.000001, -0.0001, 1 };
broadcastloop %{
loop(n) %{
  PDL_ULong a = $indsa(), b = $indsb(), nvbase = n * 5, nibase = n * 12;
  if (a >= $SIZE(v))
    $CROAK("indsa number %"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, n, a, $SIZE(v)-1);
  if (b >= $SIZE(v))
    $CROAK("indsb number %"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, n, b, $SIZE(v)-1);
  float tmp1[3], norm[3], norm2[3], partback[3];
  loop(tri) %{
    tmp1[tri] = $coords(v => a) - $coords(v => b);
    partback[tri] = $coords(v => b) + hl*tmp1[tri];
  %}
  PDL_3D_CROSS(norm, tmp1, tmp2);
  PDL_3D_CROSS(norm2, tmp1, norm);
  float wthis = w*PDL_3D_VECLEN(tmp1);
  PDL_3D_SETVECLEN(norm, wthis);
  PDL_3D_SETVECLEN(norm2, wthis);
  PDL_3D_SETVECLEN(tmp1, 1);
  loop(tri) %{ $trivertices(nv=>nvbase+0) = $coords(v => b); %}
  loop(tri) %{ $trivertices(nv=>nvbase+1) = partback[tri] + norm[tri]; %}
  loop(tri) %{ $trivertices(nv=>nvbase+2) = partback[tri] + norm2[tri]; %}
  loop(tri) %{ $trivertices(nv=>nvbase+3) = partback[tri] - norm[tri]; %}
  loop(tri) %{ $trivertices(nv=>nvbase+4) = partback[tri] - norm2[tri]; %}
  $triindices(ni=>nibase+0) =   nvbase+0;
  $triindices(ni=>nibase+1) =   nvbase+1;
  $triindices(ni=>nibase+2) =   nvbase+2;
  $triindices(ni=>nibase+3) =   nvbase+0;
  $triindices(ni=>nibase+4) =   nvbase+3;
  $triindices(ni=>nibase+5) =   nvbase+4;
  $triindices(ni=>nibase+6) =   nvbase+0;
  $triindices(ni=>nibase+7) =   nvbase+2;
  $triindices(ni=>nibase+8) =   nvbase+3;
  $triindices(ni=>nibase+9) =   nvbase+0;
  $triindices(ni=>nibase+10) =  nvbase+4;
  $triindices(ni=>nibase+11) =  nvbase+1;
%}
%}
EOF
  Doc => <<'EOF',
=for ref

Generate vertices and indices, for triangles, implementing arrowheads.
EOF
);

pp_def('triangle_normals',
  Pars => 'vertices(tri=3,v); uint faceidx(trivert=3,f); [o] facenorm(tri,f); [o] vertnorm(tri,v)',
  GenericTypes => $F,
  Code => <<'EOF',
loop(v,tri) %{ $vertnorm() = 0.0f; %}
loop(f) %{
  float tmp0_1[3], tmp0_2[3], tmpcross[3];
  PDL_ULong vertidx[3];
  loop(trivert) %{
    if ((vertidx[trivert] = $faceidx()) >= $SIZE(v))
      $CROAK("faceidx number %"IND_FLAG",%"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, f, trivert, vertidx[trivert], $SIZE(v)-1);
  %}
  loop(tri) %{
    tmp0_1[tri] = $vertices(v => vertidx[1]) - $vertices(v => vertidx[0]);
    tmp0_2[tri] = $vertices(v => vertidx[2]) - $vertices(v => vertidx[0]);
  %}
  PDL_3D_CROSS(tmpcross, tmp0_1, tmp0_2);
  PDL_3D_SETVECLEN(tmpcross, 1);
  loop(tri) %{ $facenorm() = tmpcross[tri]; %}
  loop(trivert,tri) %{ $vertnorm(v=>vertidx[trivert]) += $facenorm(); %}
%}
loop(v) %{
  float magn = sqrtf($vertnorm(tri=>0)*$vertnorm(tri=>0) + $vertnorm(tri=>1)*$vertnorm(tri=>1) + $vertnorm(tri=>2)*$vertnorm(tri=>2));
  loop(tri) %{ $vertnorm() /= magn; %}
%}
EOF
  Doc => <<'EOF',
=for ref

Generate normals for faces and vertices in a single scan.
EOF
);

pp_done();
