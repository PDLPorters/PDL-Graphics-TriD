use strict;
use warnings;
use PDL::Types qw(types ppdefs_all);

{ no warnings 'once'; # pass info back to Makefile.PL
$PDL::Core::Dev::EXTRAS{$::PDLMOD}{OBJECT} .= join '', map " $::PDLBASE-$_\$(OBJ_EXT)", qw(font sphere);
}

my $F = ['F'];

pp_addpm({At=>'Top'},<<'EOD');
=head1 NAME

PDL::Graphics::OpenGLQ - quick routines to plot lots of stuff from ndarrays.

=head1 SYNOPSIS

only for internal use - see source

=head1 DESCRIPTION

only for internal use - see source

=head1 AUTHOR

Copyright (C) 1997,1998 Tuomas J. Lukka.
All rights reserved. There is no warranty. You are allowed
to redistribute this software / documentation under certain
conditions. For details, see the file COPYING in the PDL
distribution. If this file is separated from the PDL distribution,
the copyright notice should be included in the file.

=cut

EOD

pp_addhdr('
#ifdef __APPLE__
#include <OpenGL/gl.h>
#else
#include <GL/gl.h>
#endif
');

my @internal = (Doc => 'internal', NoPthread => 1);

pp_def(
  'gl_spheres',
  GenericTypes => $F,
  Pars => 'coords(tri=3,n);',
  OtherPars => 'double radius; int slices; int stacks;',
  CHeader => "char *pdl_3d_solidSphere(double radius, GLint slices, GLint stacks);\n",
  Code => '
    float oldcoord0 = 0.0, oldcoord1 = 0.0, oldcoord2 = 0.0;
    glPushMatrix();
    loop(n) %{
      glTranslatef(
	$coords(tri=>0) - oldcoord0,
	$coords(tri=>1) - oldcoord1,
	$coords(tri=>2) - oldcoord2
      );
      char *err = pdl_3d_solidSphere($COMP(radius), $COMP(slices), $COMP(stacks));
      if (err) $CROAK("%s", err);
      oldcoord0 = $coords(tri=>0), oldcoord1 = $coords(tri=>1), oldcoord2 = $coords(tri=>2);
    %}
    glPopMatrix();
  ',
  @internal
);

sub TRI {
  my ($par, $suffix) = @_;
  $par .= $suffix if $suffix && !ref $suffix;
  my $extra_arg = ref $suffix ? "trivert => $$suffix," : '';
  join ',', map "$par(${extra_arg}tri => $_)", 0..2;
}
sub make_tri { shift()."(".TRI(@_).");\n" }
sub COLOR { make_tri("glColor3f",'$colors',@_) }
sub VERTEX { make_tri("glVertex3f",'$coords',@_) }
sub NORMAL { make_tri("glNormal3f",'$norm',@_) }
sub RPOS { make_tri("glRasterPos3f",'$coords',@_) }

sub make_func {
  my ($name) = @_;
  for (['_col', ' colors(tri=3,n);', COLOR().VERTEX()], ['_nc', '', VERTEX()]) {
    pp_def(lc($name).$_->[0],
      GenericTypes => $F,
      Pars => 'coords(tri=3,n);'.$_->[1],
      Code => '
        glBegin('.uc($name).');
        loop(n) %{'.$_->[2].'%}
        glEnd();
      ',
      @internal
    );
  }
}

make_func($_) for qw(gl_line_strip gl_lines gl_points);

pp_def(
  'gl_texts',
  GenericTypes => $F,
  Pars => 'coords(tri=3,x); ',
  OtherPars => 'SV *arr',
  CHeader => "void pdl_3d_bitmapString( const unsigned char *string );\n",
  Code => '
    SV *sv = $COMP(arr);
    if (!(SvROK(sv) && SvTYPE(SvRV(sv))==SVt_PVAV))
      $CROAK("gl_texts requires an array ref");
    AV *arr = (AV *)SvRV(sv);
    loop(x) %{
      SV *elem = *(av_fetch(arr, x, 0));
      if (!elem) continue;
      char *str = SvPV_nolen(elem);
      '.RPOS().'
      pdl_3d_bitmapString((const unsigned char *)str);
    %}
  ',
  @internal
);

for(
{Name => 'gl_triangles'},
{Name => 'gl_triangles_wn',
 NormalArgs => 'norm(tri,trivert); ',
 (map +("NormalCode$_"=>NORMAL(\$_)), 0..2),
}) {
# This may be suboptimal but should still be fast enough..
# We only do triangles with this.
pp_def(
  $_->{Name},
  GenericTypes => $F,
  Pars => 'coords(tri=3,trivert=3); '.
           ($_->{NormalArgs}//'').
          'colors(tri,trivert)',
  Code => '
glBegin(GL_TRIANGLES);
broadcastloop %{'.
  ($_->{NormalCode0}//'').
  COLOR(\0).VERTEX(\0).
  ($_->{NormalCode1}//'').
  COLOR(\1).VERTEX(\1).
  ($_->{NormalCode2}//'').
  COLOR(\2).VERTEX(\2).'
%}
glEnd();',
  @internal
);
}

pp_def('gl_arrows',
	Pars => 'coords(tri=3,n); indx indsa(); indx indsb();',
	OtherPars => 'float headlen; float width;',
	Code => <<'EOF',
float hl = $COMP(headlen);
float w = $COMP(width);
float tmp2[3] = { 0.000001, -0.0001, 1 };
broadcastloop %{
  PDL_Indx a = $indsa(), b = $indsb();
  float tmp1[3];
  float norm[3];
  float norm2[3];
  float normlen,origlen,norm2len;
  float partback[3];
  loop(tri) %{
    tmp1[tri] = $coords(n => a) - $coords(n => b);
    partback[tri] = $coords(n => b) + hl*tmp1[tri];
  %}
  norm[0] = tmp1[1]*tmp2[2] - tmp2[1]*tmp1[2];
  norm[1] = -(tmp1[0]*tmp2[2] - tmp2[0]*tmp1[2]);
  norm[2] = tmp1[0]*tmp2[1] - tmp2[0]*tmp1[1];
  norm2[0] = tmp1[1]*norm[2] - norm[1]*tmp1[2];
  norm2[1] = -(tmp1[0]*norm[2] - norm[0]*tmp1[2]);
  norm2[2] = tmp1[0]*norm[1] - norm[0]*tmp1[1];
  normlen = sqrtf(norm[0] * norm[0] + norm[1] * norm[1] + norm[2] * norm[2]);
  norm2len = sqrtf(norm2[0] * norm2[0] + norm2[1] * norm2[1] + norm2[2] * norm2[2]);
  origlen = sqrtf(tmp1[0] * tmp1[0] + tmp1[1] * tmp1[1] + tmp1[2] * tmp1[2]);
  loop(tri) %{
    norm[tri] *= w/normlen;
    norm2[tri] *= w/norm2len;
    tmp1[tri] /= origlen;
  %}
  glBegin(GL_LINES);
  glVertex3d( $coords(tri => 0, n => a) ,
              $coords(tri => 1, n => a) ,
              $coords(tri => 2, n => a) );
  glVertex3d( $coords(tri => 0, n => b) ,
              $coords(tri => 1, n => b) ,
              $coords(tri => 2, n => b) );
  glEnd();
  if(w!=0) {
  glBegin(GL_TRIANGLES);
  glVertex3d( $coords(tri => 0, n => b) ,
              $coords(tri => 1, n => b) ,
              $coords(tri => 2, n => b) );
  glVertex3d( partback[0] + norm[0],
              partback[1] + norm[1],
              partback[2] + norm[2]);
  glVertex3d( partback[0] + norm2[0],
              partback[1] + norm2[1],
              partback[2] + norm2[2]);
  glVertex3d( $coords(tri => 0, n => b) ,
              $coords(tri => 1, n => b) ,
              $coords(tri => 2, n => b) );
  glVertex3d( partback[0] - norm[0],
              partback[1] - norm[1],
              partback[2] - norm[2]);
  glVertex3d( partback[0] - norm2[0],
              partback[1] - norm2[1],
              partback[2] - norm2[2]);
  glVertex3d( $coords(tri => 0, n => b) ,
              $coords(tri => 1, n => b) ,
              $coords(tri => 2, n => b) );
  glVertex3d( partback[0] + norm2[0],
              partback[1] + norm2[1],
              partback[2] + norm2[2]);
  glVertex3d( partback[0] - norm[0],
              partback[1] - norm[1],
              partback[2] - norm[2]);
  glVertex3d( $coords(tri => 0, n => b) ,
              $coords(tri => 1, n => b) ,
              $coords(tri => 2, n => b) );
  glVertex3d( partback[0] - norm2[0],
              partback[1] - norm2[1],
              partback[2] - norm2[2]);
  glVertex3d( partback[0] + norm[0],
              partback[1] + norm[1],
              partback[2] + norm[2]);
  glEnd();
  }
%}
EOF
	@internal
);

pp_def('triangle_normals',
  Pars => 'vertices(tri=3,v); uint faceidx(trivert=3,f); [o] facenorm(tri,f); [o] vertnorm(tri,v)',
  GenericTypes => $F,
  Code => <<'EOF',
loop(v,tri) %{ $vertnorm() = 0.0f; %}
loop(f) %{
  float tmp0_1[3], tmp0_2[3], tmpcross[3], magn;
  PDL_ULong vertidx[3];
  loop(trivert) %{
    if ((vertidx[trivert] = $faceidx()) >= $SIZE(v))
      $CROAK("faceidx number %"IND_FLAG",%"IND_FLAG" out of range: %"IND_FLAG" > %"IND_FLAG, f, trivert, vertidx[trivert], $SIZE(v)-1);
  %}
  loop(tri) %{
    tmp0_1[tri] = $vertices(v => vertidx[1]) - $vertices(v => vertidx[0]);
    tmp0_2[tri] = $vertices(v => vertidx[2]) - $vertices(v => vertidx[0]);
  %}
  tmpcross[0] = tmp0_1[1]*tmp0_2[2] - tmp0_2[1]*tmp0_1[2];
  tmpcross[1] = -(tmp0_1[0]*tmp0_2[2] - tmp0_2[0]*tmp0_1[2]);
  tmpcross[2] = tmp0_1[0]*tmp0_2[1] - tmp0_2[0]*tmp0_1[1];
  magn = sqrtf(tmpcross[0]*tmpcross[0] + tmpcross[1]*tmpcross[1] + tmpcross[2]*tmpcross[2]);
  loop(tri) %{ $facenorm() = tmpcross[tri] / magn; %}
  loop(trivert,tri) %{ $vertnorm(v=>vertidx[trivert]) += $facenorm(); %}
%}
loop(v) %{
  float magn = sqrtf($vertnorm(tri=>0)*$vertnorm(tri=>0) + $vertnorm(tri=>1)*$vertnorm(tri=>1) + $vertnorm(tri=>2)*$vertnorm(tri=>2));
  loop(tri) %{ $vertnorm() /= magn; %}
%}
EOF
  @internal,
);

pp_done();
